import json
import sys
import time
from collections import defaultdict

import serial

from web3 import Web3
from web3.contract import ConciseContract

# Const
CONTRACT_ADDR = '0x3dE880494eaB2CF4257cFeb779Bc194F408d1A38'

# Get the contract info from the file generated by truffle
with open("QHacks-2019/dapp/build/contracts/SharedAssets.json") as f:
    json_data = json.load(f)
    abi = json_data['abi']
    #binn = json_data['bin']

# Access blockchain with web3
w3 = Web3(Web3.HTTPProvider("http://localhost:7545/"))

# Get the real contract object
sa_con = w3.eth.contract(address = CONTRACT_ADDR, abi = abi)
# Get an easier to use but simpler contract object
sa = ConciseContract(sa_con)

# Wrapper
def check_out_asset(asset_id, user_addr):
    try:
        w3.eth.defaultAccount = user_addr
        cost = sa.assets(asset_id)[2]
        sa_con.functions.checkOutAsset(asset_id, int(time.time()-1)).transact({'value': cost})
        return True
    except Exception as err:
        print('Error occurred checking out asset:', err)
        return False

# Wrapper
def check_in_asset(asset_id, user_addr):
    try:
        w3.eth.defaultAccount = user_addr
        sa_con.functions.checkInAsset(asset_id, int(time.time()-1)).transact()
        return True
    except Exception as err:
        print('Error occurred checking in asset:', err)
        return False

def main(args):

    # The following line is a single line, 
    # that does the fewest number of checks,
    # and is totally correct, but COMPLETELY unreadable!
    # Nested ternary operators.  Reverse code golf ftw
    # (serport, asset_id) = (args[1], int(args[2]) if len(args) > 2 else 1) if len(args) > 1 else ('COM6' , 1)

    # This looks much nicer
    serport =      args[1]  if len(args) > 1 else 'COM5'
    asset_id = int(args[2]) if len(args) > 2 else 1
    
    # Open up the arduino
    arduinoser = serial.Serial(serport, 115200, timeout = 1)
    arduinoser.close()
    arduinoser.open()

    # Fancy
    users = defaultdict(lambda: '0x0d6f370cc18FD4b4B9BAfdA58FFCD5539C61fefF')
    users['00590F7C'] = '0xaa35F630c17b01EE7ED46Be95e72e8D94788E5fe'
    users['80229B7C'] = '0x2BCC566C5f327263699c3d6296cE6BbF2E0D2C97'

    i = 0
    
    # robust

    last_time = time.time()-15
    while True:
        try:
            line = str(arduinoser.readline(), encoding='utf-8')
            if len(line) > 4 and (time.time() - last_time) > 15:
                tap_dir, tap_id = tuple(x.strip() for x in line.split(','))
                print("dir:", tap_dir)
                print("id:", tap_id)
                user_addr = users[tap_id]
                success = False
                if tap_dir == 'in':
                    success = check_in_asset(asset_id, user_addr)
                elif tap_dir == 'out':
                    success = check_out_asset(asset_id, user_addr)
                if success:
                    print("Success")
                    last_time = time.time()
        except KeyboardInterrupt:
            break
        except Exception as err:
            print(err)
            continue # This feels gross

def manual(asset_id):
    asset_id = asset_id
    user_addr = '0x0d6f370cc18FD4b4B9BAfdA58FFCD5539C61fefF'
    check_out_asset(asset_id, user_addr)
    time.sleep(15)
    check_in_asset(asset_id, user_addr)
    time.sleep(15)

if __name__ == "__main__":
    # I like this next line a lot
    sys.exit(main(sys.argv))